{"version":3,"sources":["angular-modal-service.min.js","angular-modal-service.js"],"names":["module","angular","factory","$document","$compile","$controller","$http","$rootScope","$q","$templateCache","ModalService","self","this","getTemplate","template","templateUrl","deferred","defer","resolve","cachedTemplate","get","undefined","method","url","cache","then","result","put","data","error","reject","promise","showModal","options","controllerName","controller","controllerAs","transcludeTemplateDefer","transcludeTemplate","transcludeTemplateUrl","transcludeTemp","transclude","modalScope","$new","closeDeferred","inputs","$scope","close","delay","window","setTimeout","$destroy","modalElement","remove","modal","inputName","replace","modalElementTemplate","element","linkFn","$element","modalController","appendElement","append","body","scope","find"],"mappings":"AAAA;AACA,CCKC,WAEC,YAEA,IAAIA,GAASC,QAAQD,OAAO,yBAE5BA,GAAOE,QAAQ,gBAAiB,YAAa,WAAY,cAAe,QAAS,aAAc,KAAM,iBACnG,SAASC,EAAWC,EAAUC,EAAaC,EAAOC,EAAYC,EAAIC,GAKlE,QAASC,KAEP,GAAIC,GAAOC,KAKPC,EAAc,SAASC,EAAUC,GACnC,GAAIC,GAAWR,EAAGS,OAClB,IAAGH,EACDE,EAASE,QAAQJ,OACZ,IAAGC,EAAa,CAErB,GAAII,GAAiBV,EAAeW,IAAIL,EAClBM,UAAnBF,EACDH,EAASE,QAAQC,GAIjBb,GAAOgB,OAAQ,MAAOC,IAAKR,EAAaS,OAAO,IAC5CC,KAAK,SAASC,GAEbjB,EAAekB,IAAIZ,EAAaW,EAAOE,MACvCZ,EAASE,QAAQQ,EAAOE,OACvB,SAASC,GACVb,EAASc,OAAOD,SAItBb,GAASc,OAAO,iDAElB,OAAOd,GAASe,QAGlBpB,GAAKqB,UAAY,SAASC,GAGxB,GAAIjB,GAAWR,EAAGS,QAGdiB,EAAiBD,EAAQE,UAC7B,KAAID,EAEF,MADAlB,GAASc,OAAO,qCACTd,EAASe,OAKfE,GAAQG,eACTF,EAAiBA,EAAiB,OAASD,EAAQG,aAIrD,IAAIC,GAA0B7B,EAAGS,OAkGjC,OAjGIgB,GAAQK,oBAAsBL,EAAQM,sBACxC1B,EAAYoB,EAAQK,mBAAoBL,EAAQM,uBAC7Cd,KAAK,SAASe,GACbH,EAAwBnB,QAAQsB,KAGpCH,EAAwBnB,UAE1BmB,EAAwBN,QAAQN,KAAK,SAASgB,GAE5C5B,EAAYoB,EAAQnB,SAAUmB,EAAQlB,aACnCU,KAAK,SAASX,GAGb,GAAI4B,GAAanC,EAAWoC,OAQxBC,EAAgBpC,EAAGS,QACnB4B,GACFC,OAAQJ,EACRK,MAAO,SAASrB,EAAQsB,IACT3B,SAAV2B,GAAiC,OAAVA,KAAgBA,EAAQ,GAClDC,OAAOC,WAAW,WAEhBN,EAAc1B,QAAQQ,GAGtBgB,EAAWS,WACXC,EAAaC,SAKbR,EAAOE,MAAQ,KACf/B,EAAW,KACX4B,EAAgB,KAChBU,EAAQ,KACRT,EAAS,KACTO,EAAe,KACfV,EAAa,MACZM,IAKP,IAAGf,EAAQY,OACT,IAAI,GAAIU,KAAatB,GAAQY,OAC3BA,EAAOU,GAAatB,EAAQY,OAAOU,EAGnCd,KACF3B,EAAW2B,EAAWe,QAAQ,oBAAqB1C,GAGrD,IAAI2C,GAAuBxD,QAAQyD,QAAQ5C,GAIvC6C,EAASvD,EAASqD,GAClBL,EAAeO,EAAOjB,EAC1BG,GAAOe,SAAWR,CAGlB,IAAIS,GAAkBxD,EAAY6B,EAAgBW,EAG9CZ,GAAQ6B,cAEV7B,EAAQ6B,cAAcC,OAAOX,GAG7BY,EAAKD,OAAOX,EAId,IAAIE,IACFnB,WAAY0B,EACZI,MAAOvB,EACPgB,QAASN,EACTL,MAAOH,EAAcb,QAIvBf,GAASE,QAAQoC,KAGlB7B,KAAK,KAAM,SAASI,GACnBb,EAASc,OAAOD,OAKfb,EAASe,SAzJpB,GAAIiC,GAAO7D,EAAU+D,KAAK,OA8J1B,OAAO,IAAIxD","file":"angular-modal-service.min.js","sourcesContent":["/*angular-modal-service v0.6.7 - https://github.com/dwmkerr/angular-modal-service */\n!function(){\"use strict\";var e=angular.module(\"angularModalService\",[]);e.factory(\"ModalService\",[\"$document\",\"$compile\",\"$controller\",\"$http\",\"$rootScope\",\"$q\",\"$templateCache\",function(e,n,t,l,r,o,a){function c(){var e=this,c=function(e,n){var t=o.defer();if(e)t.resolve(e);else if(n){var r=a.get(n);void 0!==r?t.resolve(r):l({method:\"GET\",url:n,cache:!0}).then(function(e){a.put(n,e.data),t.resolve(e.data)},function(e){t.reject(e)})}else t.reject(\"No template or templateUrl has been specified.\");return t.promise};e.showModal=function(e){var l=o.defer(),a=e.controller;if(!a)return l.reject(\"No controller has been specified.\"),l.promise;e.controllerAs&&(a=a+\" as \"+e.controllerAs);var i=o.defer();return e.transcludeTemplate||e.transcludeTemplateUrl?template=c(e.transcludeTemplate,e.transcludeTemplateUrl).then(function(e){i.resolve(e)}):i.resolve(),i.promise.then(function(i){c(e.template,e.templateUrl).then(function(c){var s=r.$new(),p=o.defer(),d={$scope:s,close:function(e,n){(void 0===n||null===n)&&(n=0),window.setTimeout(function(){p.resolve(e),s.$destroy(),h.remove(),d.close=null,l=null,p=null,T=null,d=null,h=null,s=null},n)}};if(e.inputs)for(var m in e.inputs)d[m]=e.inputs[m];i&&(c=i.replace(/\\<transclude\\>/gim,c));var f=angular.element(c),v=n(f),h=v(s);d.$element=h;var $=t(a,d);e.appendElement?e.appendElement.append(h):u.append(h);var T={controller:$,scope:s,element:h,close:p.promise};l.resolve(T)}).then(null,function(e){l.reject(e)})}),l.promise}}var u=e.find(\"body\");return new c}])}();\n//# sourceMappingURL=angular-modal-service.min.js.map","//  angularModalService.js\n//\n//  Service for showing modal dialogs.\n\n/***** JSLint Config *****/\n/*global angular  */\n(function() {\n\n  'use strict';\n\n  var module = angular.module('angularModalService', []);\n\n  module.factory('ModalService', ['$document', '$compile', '$controller', '$http', '$rootScope', '$q', '$templateCache',\n    function($document, $compile, $controller, $http, $rootScope, $q, $templateCache) {\n\n    //  Get the body of the document, we'll add the modal to this.\n    var body = $document.find('body');\n\n    function ModalService() {\n\n      var self = this;\n\n      //  Returns a promise which gets the template, either\n      //  from the template parameter or via a request to the\n      //  template url parameter.\n      var getTemplate = function(template, templateUrl) {\n        var deferred = $q.defer();\n        if(template) {\n          deferred.resolve(template);\n        } else if(templateUrl) {\n          // check to see if the template has already been loaded\n          var cachedTemplate = $templateCache.get(templateUrl);\n          if(cachedTemplate !== undefined) {\n            deferred.resolve(cachedTemplate);\n          }\n          // if not, let's grab the template for the first time\n          else {\n            $http({method: 'GET', url: templateUrl, cache: true})\n              .then(function(result) {\n                // save template into the cache and return the template\n                $templateCache.put(templateUrl, result.data);\n                deferred.resolve(result.data);\n              }, function(error) {\n                deferred.reject(error);\n              });\n          }\n        } else {\n          deferred.reject(\"No template or templateUrl has been specified.\");\n        }\n        return deferred.promise;\n      };\n\n      self.showModal = function(options) {\n\n        //  Create a deferred we'll resolve when the modal is ready.\n        var deferred = $q.defer();\n\n        //  Validate the input parameters.\n        var controllerName = options.controller;\n        if(!controllerName) {\n          deferred.reject(\"No controller has been specified.\");\n          return deferred.promise;\n        }\n\n        //  If a 'controllerAs' option has been provided, we change the controller\n        //  name to use 'as' syntax. $controller will automatically handle this.\n        if(options.controllerAs) {\n          controllerName = controllerName + \" as \" + options.controllerAs;\n        }\n\n        //  Added options.transclude for templating by Tom√°s Ruiz\n        var transcludeTemplateDefer = $q.defer();\n        if (options.transcludeTemplate || options.transcludeTemplateUrl){\n          getTemplate(options.transcludeTemplate, options.transcludeTemplateUrl)\n            .then(function(transcludeTemp) {\n              transcludeTemplateDefer.resolve(transcludeTemp);\n            });\n        } else {\n          transcludeTemplateDefer.resolve();\n        }\n        transcludeTemplateDefer.promise.then(function(transclude) {\n          //  Get the actual html of the template.\n          getTemplate(options.template, options.templateUrl)\n            .then(function(template) {\n\n              //  Create a new scope for the modal.\n              var modalScope = $rootScope.$new();\n\n              //  Create the inputs object to the controller - this will include\n              //  the scope, as well as all inputs provided.\n              //  We will also create a deferred that is resolved with a provided\n              //  close function. The controller can then call 'close(result)'.\n              //  The controller can also provide a delay for closing - this is\n              //  helpful if there are closing animations which must finish first.\n              var closeDeferred = $q.defer();\n              var inputs = {\n                $scope: modalScope,\n                close: function(result, delay) {\n                  if(delay === undefined || delay === null) delay = 0;\n                  window.setTimeout(function() {\n                    //  Resolve the 'close' promise.\n                    closeDeferred.resolve(result);\n\n                    //  We can now clean up the scope and remove the element from the DOM.\n                    modalScope.$destroy();\n                    modalElement.remove();\n                    \n                    //  Unless we null out all of these objects we seem to suffer\n                    //  from memory leaks, if anyone can explain why then I'd \n                    //  be very interested to know.\n                    inputs.close = null;\n                    deferred = null;\n                    closeDeferred = null;\n                    modal = null;\n                    inputs = null;\n                    modalElement = null;\n                    modalScope = null;\n                  }, delay);\n                }\n              };\n\n              //  If we have provided any inputs, pass them to the controller.\n              if(options.inputs) {\n                for(var inputName in options.inputs) {\n                  inputs[inputName] = options.inputs[inputName];\n                }\n              }\n              if (transclude){\n                template = transclude.replace(/\\<transclude\\>/gim, template);\n              }\n              //  Parse the modal HTML into a DOM element (in template form).\n              var modalElementTemplate = angular.element(template);\n\n              //  Compile then link the template element, building the actual element.\n              //  Set the $element on the inputs so that it can be injected if required.\n              var linkFn = $compile(modalElementTemplate);\n              var modalElement = linkFn(modalScope);\n              inputs.$element = modalElement;\n\n              //  Create the controller, explicitly specifying the scope to use.\n              var modalController = $controller(controllerName, inputs);\n\n              //  Finally, append the modal to the dom.\n              if (options.appendElement) {\n                // append to custom append element\n                options.appendElement.append(modalElement);\n              } else {\n                // append to body when no custom append element is specified\n                body.append(modalElement);\n              }\n\n              //  We now have a modal object...\n              var modal = {\n                controller: modalController,\n                scope: modalScope,\n                element: modalElement,\n                close: closeDeferred.promise\n              };\n\n              //  ...which is passed to the caller via the promise.\n              deferred.resolve(modal);\n\n            })\n            .then(null, function(error) { // 'catch' doesn't work in IE8.\n              deferred.reject(error);\n            });\n          \n        });\n\n        return deferred.promise;\n      };\n\n    }\n\n    return new ModalService();\n  }]);\n\n}());\n"],"sourceRoot":"/source/"}